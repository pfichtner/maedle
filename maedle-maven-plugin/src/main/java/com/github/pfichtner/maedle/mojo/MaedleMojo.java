package com.github.pfichtner.maedle.mojo;

import static com.pfichtner.github.maedle.transform.ResourceAddables.writeToDirectory;
import static com.pfichtner.github.maedle.transform.util.CollectionUtil.functionForMapWithProvider;
import static com.pfichtner.github.maedle.transform.util.CollectionUtil.nonNull;
import static com.pfichtner.github.maedle.transform.util.IoUtils.copyTree;
import static java.nio.file.Files.walkFileTree;
import static java.util.stream.Collectors.toMap;
import static org.apache.maven.plugins.annotations.LifecyclePhase.PROCESS_CLASSES;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

import org.apache.maven.model.Resource;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.objectweb.asm.Type;

import com.github.pfichtner.maedle.transform.util.jar.PluginInfo;
import com.pfichtner.github.maedle.transform.ResourceAddable;
import com.pfichtner.github.maedle.transform.TransformMojoVisitor;

@Mojo(name = MaedleMojo.GOAL, defaultPhase = PROCESS_CLASSES)
public class MaedleMojo extends AbstractMojo {
	
	public static class Mapping {

		public String id;
		public String pluginId;
		public String extension;

		public Mapping() {
			super();
		}

		public Mapping(Class<?> mojoClass, String pluginId, String extension) {
			this(mojoClass.getName().replace('.', '/'), pluginId, extension);
		}

		public Mapping(String id, String pluginId, String extension) {
			this.id = id;
			this.pluginId = pluginId;
			this.extension = extension;
		}

	}

	public static final String GOAL = "transform";

//	@Parameter(defaultValue = "${project}", required = true, readonly = true)
	@Component
	private MavenProject project;

	/**
	 * The directory where processed resources will be placed for packaging.
	 */
	@Parameter(defaultValue = "${project.build.directory}/maedle-transformed-classes")
	public File outputDirectory;

	@Parameter(defaultValue = "${project.build.outputDirectory}", required = true)
	public File classesDirectory;

	/**
	 * Only transform mojos that are mapped. When set to false and a mapping is not
	 * found the mapping values are autogenerated.
	 */
	@Parameter(name = "transformOnlyIfConfigured")
	public boolean transformOnlyIfConfigured;

	@Parameter(name = "mappings")
	public List<Mapping> mappings;

//	@Component
//	private MavenProjectHelper projectHelper;
//
//	@Component(role = Archiver.class, hint = "jar")
//	private JarArchiver jarArchiver;
//
//
//	@Parameter(defaultValue = "${project.build.directory}", readonly = true, required = true)
//	private File outputDirectory;
//
//	@Parameter(defaultValue = "${project.build.finalName}", alias = "jarName", required = true)
//	private String finalName;

	@Override
	public void execute() throws MojoExecutionException, MojoFailureException {
		if (classesDirectory.exists()) {
			// TODO project.isExecutionRoot();
			if (!outputDirectory.exists() && !outputDirectory.mkdirs()) {
				throw new MojoExecutionException("Cannot create output directory " + outputDirectory);
			}
			transform();
		}
	}

	private void transform() throws MojoFailureException {
		TransformMojoVisitor visitor = new TransformMojoVisitor(FileSystems.getDefault(),
				combine(log(), writeToDirectory(outputDirectory)), pluginInfoProvider()).withCopy(false);
		try {
			walkFileTree(classesDirectory.toPath(), visitor);
			walkFileTree(outputDirectory.toPath(), copyTree(outputDirectory, classesDirectory));
		} catch (IOException e) {
			throw new MojoFailureException("error reading " + classesDirectory, e);
		}

//		Resource resource = resource();
//		getLog().info("Adding resource " + resource);
//		project.addResource(resource);
	}

	private Function<Type, PluginInfo> pluginInfoProvider() {
		Map<Type, PluginInfo> map = getMappings();
		return transformOnlyIfConfigured ? map::get : functionForMapWithProvider(map, MaedleMojo::defaultPluginInfo);
	}

	private Map<Type, PluginInfo> getMappings() {
		return nonNull(mappings).stream()
				.collect(toMap(m -> Type.getObjectType(m.id), m -> new PluginInfo(m.pluginId, m.extension)));
	}

	private static PluginInfo defaultPluginInfo(Type type) {
		String className = type.getClassName();
		int lastDotAt = className.lastIndexOf('.');
		return new PluginInfo(lastDotAt >= 0 ? className.substring(0, lastDotAt) : className, "extname");
	}

	private Resource resource() {
		Resource resource = new Resource();
		resource.setDirectory(outputDirectory.toString());
		return resource;
	}

	private ResourceAddable log() {
		return (content, path) -> getLog().info("Adding " + path + " to " + outputDirectory);
	}

	private static ResourceAddable combine(ResourceAddable addable1, ResourceAddable addable2) {
		return (content, path) -> {
			addable1.add(content, path);
			addable2.add(content, path);
		};
	}

	public MavenProject getProject() {
		return project;
	}

}
